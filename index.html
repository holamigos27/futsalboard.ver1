<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Futsal Board - Precision Edition</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #2c3e50; margin: 0; padding: 10px; }
        .controls { background: white; padding: 12px; border-radius: 10px; margin-bottom: 10px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3); max-width: 1300px; }
        .canvas-container { position: relative; background: #fff; border: 2px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; touch-action: none; cursor: crosshair; }
        button { padding: 6px 10px; font-weight: bold; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; background: white; font-size: 13px; color: #333; -webkit-tap-highlight-color: transparent; }
        button:hover { background: #f8f9fa; }
        .active { background: #000 !important; color: #fff !important; }
        .label { font-size: 11px; color: #666; display: block; text-align: center; margin-bottom: 4px; }
        .group { border-right: 1px solid #eee; padding: 0 10px; display: flex; flex-direction: column; justify-content: flex-start; }
        .btn-delete { color: #e74c3c; border-color: #e74c3c; }
        .btn-save { background: #2ecc71 !important; color: white !important; border-color: #27ae60 !important; }
        .btn-data { background: #3498db !important; color: white !important; border-color: #2980b9 !important; }
        #saveList { padding: 4px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px; max-width: 120px; }
        .color-dot { width: 22px; height: 22px; border-radius: 50%; border: 2px solid #ddd; cursor: pointer; }
        #text-editor-panel {
            position: fixed; left: 10px; top: 100px; width: 120px; background: white; padding: 15px 10px; border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: none; flex-direction: column; gap: 15px; z-index: 100; border-left: 5px solid #3498db;
        }
    </style>
</head>
<body>

<div id="text-editor-panel">
    <div style="color: #3498db; font-size: 13px; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 5px; text-align: center;">TEXT設定</div>
    <div style="display: flex; flex-direction: column; gap: 5px; font-size: 12px;">文字色<input type="color" id="editorTextColor" oninput="updateTextFromPanel()"></div>
    <div style="display: flex; flex-direction: column; gap: 5px; font-size: 12px;"><label><input type="checkbox" id="editorBgEnable" onchange="updateTextFromPanel()"> 背景色</label><input type="color" id="editorBgColor" value="#ffffff" oninput="updateTextFromPanel()"></div>
    <div style="display: flex; flex-direction: column; gap: 5px; font-size: 12px;">サイズ<input type="number" id="editorFontSize" min="8" max="200" oninput="updateTextFromPanel()"></div>
</div>

<div class="controls">
    <div class="group">
        <span class="label">データ保存・復元</span>
        <div style="display: flex; flex-direction: column; gap: 4px;">
            <div style="display: flex; gap: 4px;">
                <button class="btn-data" onclick="saveToStorage()">保存</button>
                <select id="saveList"><option value="">選択してください</option></select>
            </div>
            <div style="display: flex; gap: 4px;">
                <button onclick="loadFromStorage()">読込</button>
                <button class="btn-delete" onclick="deleteFromStorage()">削除</button>
            </div>
        </div>
    </div>
    <div class="group">
        <span class="label">テンプレート配置</span>
        <div style="display: flex; flex-direction: column; gap: 4px;">
            <button onclick="applyTemplate('default')">一括配置</button>
            <div style="display: flex; gap: 4px;">
                <button onclick="applyTemplate('3-1')">3-1</button>
                <button onclick="applyTemplate('4-0')">4-0</button>
            </div>
        </div>
    </div>
    <div class="group">
        <span class="label">選手・GL追加</span>
        <div style="display: flex; flex-direction: column; gap: 4px;">
            <div style="display: flex; gap: 4px;">
                <button onclick="addPlayer('home')">味方+</button>
                <button onclick="addSpecial('GL')">GL+</button>
                <button onclick="toggleBall()">⚽</button>
            </div>
            <div style="display: flex; gap: 4px;">
                <button onclick="addPlayer('away')">敵+</button>
                <button onclick="addSpecial('xGL')">xGL+</button>
            </div>
        </div>
    </div>
    <div class="group">
        <span class="label">色</span>
        <div style="display: flex; flex-direction: column; gap: 4px; margin-top: 4px; align-items: center;">
            <div style="display: flex; gap: 4px;">
                <div class="color-dot" style="background:#000000" onclick="changeColor('#000000')"></div>
                <div class="color-dot" style="background:#3498db" onclick="changeColor('#3498db')"></div>
            </div>
            <div style="display: flex; gap: 4px;">
                <div class="color-dot" style="background:#e74c3c" onclick="changeColor('#e74c3c')"></div>
                <div class="color-dot" style="background:#2ecc71" onclick="changeColor('#2ecc71')"></div>
            </div>
        </div>
    </div>
    <div class="group">
        <span class="label">モード・図形・テキスト</span>
        <div style="display: flex; gap: 4px;">
            <button id="moveBtn" onclick="setMode('move')">選択</button>
            <button id="drawBtn" class="active" onclick="setMode('draw')">ペン</button>
            <button id="shapeBtn" onclick="setMode('shape')">図形</button>
            <button id="textBtn" onclick="setMode('text')">Ｔ</button>
        </div>
        <div style="display: flex; gap: 4px; margin-top: 4px; align-items: center;">
            <button id="circBtn" onclick="setShapeType('circle')">○</button>
            <button id="rectBtn" onclick="setShapeType('rect')">□</button>
            <button id="triBtn" onclick="setShapeType('tri')">△</button>
            <button id="fillBtn" onclick="toggleFill()">塗</button>
            <button id="strokeBtn" class="active" onclick="toggleStroke()">枠</button>
            <input type="range" id="opacityRange" min="0.1" max="1.0" step="0.1" value="0.5" oninput="changeOpacity(this.value)">
        </div>
    </div>
    <div class="group">
        <span class="label">線の形状</span>
        <div style="margin-bottom:4px; display: flex; gap: 4px;">
            <button id="solidBtn" class="active" onclick="changeLineStyle('solid')">実線</button>
            <button id="dashedBtn" onclick="changeLineStyle('dashed')">点線</button>
            <button id="zigzagBtn" onclick="changeLineStyle('zigzag')">波線</button>
        </div>
        <div style="display: flex; gap: 4px;">
            <button id="straightBtn" class="active" onclick="changeLineType('straight')">／ 直線</button>
            <button id="curveBtn" onclick="changeLineType('curve')">～ 曲線</button>
            <button id="orthoBtn" onclick="changeLineType('ortho')">└┐ 直角</button>
        </div>
    </div>
    <div class="group">
        <span class="label">終点</span>
        <div style="display: flex; flex-direction: column; gap: 4px;">
            <div style="display: flex; gap: 4px;">
                <button id="termArrowBtn" class="active" onclick="changeTerminal('arrow')">矢印</button>
                <button id="termBlockBtn" onclick="changeTerminal('block')">停止</button>
            </div>
            <button id="termNoneBtn" onclick="changeTerminal('none')">なし</button>
        </div>
    </div>
    <div class="group" style="border:none;">
        <span class="label">表示・操作</span>
        <div style="display: flex; gap: 4px;">
            <button id="toggleZonesBtn" onclick="toggleZones()">ゾーン</button>
            <button id="lane3Btn" onclick="setLanes(3)">3L</button>
            <button id="lane4Btn" onclick="setLanes(4)">4L</button>
            <button id="laneOffBtn" class="active" onclick="setLanes(0)">OFF</button>
            <button id="toggleOrientationBtn" onclick="toggleOrientation()">向き：横</button>
            <button class="btn-delete" onclick="deleteSelected()">消去</button>
            <button onclick="undo()">↩</button>
            <button onclick="clearAll()">Reset</button>
            <button class="btn-save" onclick="exportImage()">画像保存</button>
        </div>
    </div>
</div>

<div class="canvas-container">
    <canvas id="canvas" width="800" height="500"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let objects = [], history = [], mode = 'draw', isMouseDown = false;
    let selectedObjs = [], currentLine = null, lastPos = { x: 0, y: 0 }, activePoint = null;
    let selectionBox = null, isDragging = false;
    let currentPenStyle = 'solid', currentLineType = 'straight', currentShapeType = 'circle';
    let currentTerminal = 'arrow', currentOpacity = 0.5, isFill = false, isStroke = true;
    let isPortrait = false, showZones = false, laneMode = 0, tempShape = null;

    const STORAGE_KEY = "FUTSAL_BOARD_SAVES";

    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - rect.left) * (canvas.width / rect.width),
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    function handleStart(e) {
        if (e.type === 'touchstart') e.preventDefault();
        const pos = getPointerPos(e);
        const mx = pos.x, my = pos.y;
        
        isMouseDown = true; lastPos = { x: mx, y: my }; activePoint = null; isDragging = false; selectionBox = null;
        
        if (mode === 'text') { 
            const txt = prompt("テキスト:"); 
            if (txt) { save(); objects.push({ type: 'text', x: mx, y: my, text: txt, color: '#000000', fontSize: 24, bgColor: null }); } 
            isMouseDown = false; render(); return; 
        }

        // ハンドル判定しきい値を 20 -> 10 に縮小
        for (let obj of selectedObjs) {
            if (obj.type === 'text') { 
                const w = obj._lastW, h = obj._lastH; 
                const handles = [{x: obj.x-5, y: obj.y-5, id: 'lt'}, {x: obj.x+w+5, y: obj.y-5, id: 'rt'}, {x: obj.x-5, y: obj.y+h+5, id: 'lb'}, {x: obj.x+w+5, y: obj.y+h+5, id: 'rb'}]; 
                for(let hdl of handles) { if (Math.sqrt((mx-hdl.x)**2 + (my-hdl.y)**2) < 10) { activePoint = { parent: obj, handle: hdl.id }; return; } } 
            }
            if (obj.points) { for(let p of obj.points) { if (Math.sqrt((mx-p.x)**2 + (my-p.y)**2) < 10) { activePoint = p; return; } } }
        }

        let found = objects.slice().reverse().find(o => {
            // 全体的に判定距離（しきい値）を半分以下に縮小
            if (o.type === 'player') return Math.sqrt((mx-o.x)**2 + (my-o.y)**2) < 14; 
            if (o.type === 'text') return mx >= o.x - 2 && mx <= o.x + o._lastW + 2 && my >= o.y - 2 && my <= o.y + o._lastH + 2;
            if (o.type === 'shape') {
                if (o.points.some(p => Math.sqrt((mx-p.x)**2 + (my-p.y)**2) < 8)) return true;
                if (o.isFill && mx > Math.min(...o.points.map(p=>p.x)) && mx < Math.max(...o.points.map(p=>p.x)) && my > Math.min(...o.points.map(p=>p.y)) && my < Math.max(...o.points.map(p=>p.y))) return true;
                for(let i=0; i<o.points.length; i++){ if (o.shape === 'circle') { const r = Math.sqrt(Math.pow(o.points[1].x-o.points[0].x,2) + Math.pow(o.points[1].y-o.points[0].y,2)); if (Math.abs(Math.sqrt((mx-o.points[0].x)**2 + (my-o.points[0].y)**2)-r) < 8) return true; } else if (distToSegment(mx, my, o.points[i], o.points[(i+1)%o.points.length]) < 8) return true; }
                return false;
            }
            const threshold = 8; // 線の選択感度を鋭敏に
            if(o.lineType === 'ortho') { for(let i=1; i<o.points.length; i++) { let flip = o.flipOrtho; if(i%2===0) flip = !flip; let corner = flip ? {x:o.points[i-1].x, y:o.points[i].y} : {x:o.points[i].x, y:o.points[i-1].y}; if(distToSegment(mx,my,o.points[i-1],corner) < threshold || distToSegment(mx,my,corner,o.points[i]) < threshold) return true; } return false; }
            for (let i = 1; i < o.points.length; i++) { if (distToSegment(mx, my, o.points[i-1], o.points[i]) < threshold) return true; }
            return false;
        });

        if (found) { isDragging = true; if (!selectedObjs.includes(found)) selectedObjs = [found]; } 
        else {
            if (mode === 'move') { selectedObjs = []; selectionBox = { startX: mx, startY: my, x: mx, y: my, w: 0, h: 0 }; } 
            else if (mode === 'shape') { tempShape = { type: 'shape', shape: currentShapeType, points: [{x:mx, y:my}, {x:mx, y:my}, {x:mx, y:my}, {x:mx, y:my}], color: '#3498db', style: currentPenStyle, isFill: isFill, isStroke: isStroke, opacity: currentOpacity, startX: mx, startY: my }; } 
            else {
                save(); let pts = [{x: mx, y: my}, {x: mx, y: my}]; if(currentLineType === 'curve') pts.splice(1, 0, {x: mx, y: my});
                currentLine = { type: 'line', points: pts, style: currentPenStyle, terminal: currentTerminal, lineType: currentLineType, color: '#000000', flipOrtho: false };
                objects.push(currentLine); selectedObjs = [currentLine]; activePoint = currentLine.points[currentLine.points.length-1];
            }
        }
        render();
    }

    function handleMove(e) {
        if (!isMouseDown) return;
        if (e.type === 'touchmove') e.preventDefault();
        const pos = getPointerPos(e);
        const mx = pos.x, my = pos.y;
        if (activePoint && activePoint.handle) {
            const obj = activePoint.parent; const dx = mx - lastPos.x; const sizeChange = (activePoint.handle.includes('r') ? dx : -dx) / ((obj._lastW / obj.fontSize) * 0.5); const newSize = Math.max(8, (obj.fontSize || 24) + sizeChange);
            if (activePoint.handle.includes('l')) { const oldW = obj._lastW; obj.fontSize = newSize; ctx.font = newSize + "px sans-serif"; obj.x -= (ctx.measureText(obj.text).width - oldW); } else { obj.fontSize = newSize; }
            lastPos = { x: mx, y: my };
        } else if (selectionBox) { 
            selectionBox.x = Math.min(mx, selectionBox.startX); selectionBox.y = Math.min(my, selectionBox.startY); selectionBox.w = Math.abs(mx - selectionBox.startX); selectionBox.h = Math.abs(my - selectionBox.startY); selectedObjs = objects.filter(o => { const bx = (o.type === 'player' || o.type === 'text') ? o.x : o.points[0].x, by = (o.type === 'player' || o.type === 'text') ? o.y : o.points[0].y; return bx >= selectionBox.x && bx <= selectionBox.x + selectionBox.w && by >= selectionBox.y && by <= selectionBox.y + selectionBox.h; }); 
        } else if (activePoint) { activePoint.x = mx; activePoint.y = my; } else if (tempShape) { const x1 = tempShape.startX, y1 = tempShape.startY; if (tempShape.shape === 'rect') tempShape.points = [{x:x1, y:y1}, {x:mx, y:y1}, {x:mx, y:my}, {x:x1, y:my}]; else if (tempShape.shape === 'tri') tempShape.points = [{x:(x1+mx)/2, y:y1}, {x:mx, y:my}, {x:x1, y:my}]; else if (tempShape.shape === 'circle') tempShape.points = [{x:x1, y:y1}, {x:mx, y:my}]; } else if (isDragging || (selectedObjs.length > 0 && isMouseDown)) { const dx = mx - lastPos.x, dy = my - lastPos.y; selectedObjs.forEach(o => { if (o.type === 'player' || o.type === 'text') { o.x += dx; o.y += dy; } else if (o.points) o.points.forEach(p => { p.x += dx; p.y += dy; }); }); lastPos = { x: mx, y: my }; }
        render();
    }

    function handleEnd() {
        if (tempShape) { save(); objects.push(tempShape); selectedObjs = [tempShape]; tempShape = null; } 
        isMouseDown = false; activePoint = null; currentLine = null; selectionBox = null; isDragging = false; 
        render();
    }

    canvas.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('touchend', handleEnd);

    function updateSaveList() { const list = document.getElementById('saveList'); list.innerHTML = '<option value="">選択してください</option>'; const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); Object.keys(data).forEach(name => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; list.appendChild(opt); }); }
    function saveToStorage() { const name = prompt("保存名:", "データ" + document.getElementById('saveList').options.length); if (!name) return; const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); data[name] = { objects: objects, isPortrait: isPortrait, showZones: showZones, laneMode: laneMode, canvasW: canvas.width, canvasH: canvas.height }; localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); updateSaveList(); }
    
    // データ読込時に確認ダイアログを追加
    function loadFromStorage() { 
        const name = document.getElementById('saveList').value; 
        if (!name) return; 
        if (!confirm(`データ「${name}」を読み込みますか？\n（現在の編集内容は上書きされます）`)) return;
        const allData = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); 
        const data = allData[name]; 
        if (!data) return; 
        save(); // 読込前もUndoできるように履歴へ保存
        objects = data.objects; isPortrait = data.isPortrait; showZones = data.showZones; laneMode = data.laneMode; canvas.width = data.canvasW || 800; canvas.height = data.canvasH || 500; document.getElementById('toggleOrientationBtn').innerText = isPortrait ? "向き：縦" : "向き：横"; render(); 
    }
    
    function deleteFromStorage() { const name = document.getElementById('saveList').value; if (!name || !confirm("削除しますか？")) return; const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); delete data[name]; localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); updateSaveList(); }
    function save() { history.push(JSON.stringify(objects)); if (history.length > 50) history.shift(); }

    function drawCourt(targetCtx) {
        const w = canvas.width, h = canvas.height, margin = 20, pitchW = w - margin * 2, pitchH = h - margin * 2, goalW = 60, radius = 100;
        targetCtx.save();
        targetCtx.strokeStyle = "#bdc3c7"; targetCtx.lineWidth = 1; targetCtx.setLineDash([]);
        if (showZones) {
            if (!isPortrait) { const third = pitchW / 3; targetCtx.beginPath(); targetCtx.moveTo(margin + third, margin); targetCtx.lineTo(margin + third, h - margin); targetCtx.moveTo(margin + third * 2, margin); targetCtx.lineTo(margin + third * 2, h - margin); targetCtx.stroke(); }
            else { const third = pitchH / 3; targetCtx.beginPath(); targetCtx.moveTo(margin, margin + third); targetCtx.lineTo(w - margin, margin + third); targetCtx.moveTo(margin, margin + third * 2); targetCtx.lineTo(w - margin, margin + third * 2); targetCtx.stroke(); }
        }
        if (laneMode > 0) {
            const unit = !isPortrait ? pitchH / laneMode : pitchW / laneMode;
            for(let i=1; i<laneMode; i++) { targetCtx.beginPath(); if(!isPortrait) { targetCtx.moveTo(margin, margin + unit * i); targetCtx.lineTo(w - margin, margin + unit * i); } else { targetCtx.moveTo(margin + unit * i, margin); targetCtx.lineTo(margin + unit * i, h - margin); } targetCtx.stroke(); }
        }
        targetCtx.restore();
        targetCtx.strokeStyle = "#333"; targetCtx.fillStyle = "#333"; targetCtx.lineWidth = 1.5; targetCtx.setLineDash([]);
        targetCtx.strokeRect(margin, margin, pitchW, pitchH);
        if (!isPortrait) {
            targetCtx.beginPath(); targetCtx.moveTo(w/2, margin); targetCtx.lineTo(w/2, h-margin); targetCtx.stroke();
            targetCtx.beginPath(); targetCtx.arc(w/2, h/2, 60, 0, Math.PI*2); targetCtx.stroke();
            const subDist = 80;
            [w/2 - subDist, w/2 + subDist].forEach(x => { targetCtx.beginPath(); targetCtx.moveTo(x, margin-5); targetCtx.lineTo(x, margin+10); targetCtx.stroke(); targetCtx.beginPath(); targetCtx.moveTo(x, h-margin+5); targetCtx.lineTo(x, h-margin-10); targetCtx.stroke(); });
            const drawD = (side) => {
                const centerX = side === 'left' ? margin : w - margin, dir = side === 'left' ? 1 : -1;
                targetCtx.beginPath();
                if (side === 'left') { targetCtx.arc(centerX, h/2 - goalW/2, radius, Math.PI*1.5, 0, false); targetCtx.lineTo(centerX + radius, h/2 + goalW/2); targetCtx.arc(centerX, h/2 + goalW/2, radius, 0, Math.PI*0.5, false); }
                else { targetCtx.arc(centerX, h/2 - goalW/2, radius, Math.PI*1.5, Math.PI, true); targetCtx.lineTo(centerX - radius, h/2 + goalW/2); targetCtx.arc(centerX, h/2 + goalW/2, radius, Math.PI, Math.PI*0.5, true); }
                targetCtx.stroke();
                targetCtx.lineWidth = 2; targetCtx.beginPath(); targetCtx.moveTo(centerX, h/2 - goalW/2); targetCtx.lineTo(centerX - dir*15, h/2 - goalW/2); targetCtx.lineTo(centerX - dir*15, h/2 + goalW/2); targetCtx.lineTo(centerX, h/2 + goalW/2); targetCtx.stroke();
            };
            drawD('left'); drawD('right');
        } else {
            targetCtx.beginPath(); targetCtx.moveTo(margin, h/2); targetCtx.lineTo(w-margin, h/2); targetCtx.stroke();
            targetCtx.beginPath(); targetCtx.arc(w/2, h/2, 60, 0, Math.PI*2); targetCtx.stroke();
            const subDist = 80;
            [h/2 - subDist, h/2 + subDist].forEach(y => { targetCtx.beginPath(); targetCtx.moveTo(margin-5, y); targetCtx.lineTo(margin+10, y); targetCtx.stroke(); targetCtx.beginPath(); targetCtx.moveTo(w-margin+5, y); targetCtx.lineTo(w-margin-10, y); targetCtx.stroke(); });
            const drawDVertical = (side) => {
                const centerY = side === 'top' ? margin : h - margin, dir = side === 'top' ? 1 : -1;
                targetCtx.beginPath();
                if (side === 'top') { targetCtx.arc(w/2 - goalW/2, centerY, radius, Math.PI, 0.5 * Math.PI, true); targetCtx.lineTo(w/2 + goalW/2, centerY + radius); targetCtx.arc(w/2 + goalW/2, centerY, radius, 0.5 * Math.PI, 0, true); }
                else { targetCtx.arc(w/2 - goalW/2, centerY, radius, Math.PI, 1.5 * Math.PI, false); targetCtx.lineTo(w/2 + goalW/2, centerY - radius); targetCtx.arc(w/2 + goalW/2, centerY, radius, 1.5 * Math.PI, 0, false); }
                targetCtx.stroke();
                targetCtx.lineWidth = 2; targetCtx.beginPath(); targetCtx.moveTo(w/2 - goalW/2, centerY); targetCtx.lineTo(w/2 - goalW/2, centerY - dir*15); targetCtx.lineTo(w/2 + goalW/2, centerY - dir*15); targetCtx.lineTo(w/2 + goalW/2, centerY); targetCtx.stroke();
            };
            drawDVertical('top'); drawDVertical('bottom');
        }
    }

    function toggleZones() { showZones = !showZones; document.getElementById('toggleZonesBtn').className = showZones ? "active" : ""; render(); }
    function setLanes(m) { laneMode = m; ['lane3Btn','lane4Btn','laneOffBtn'].forEach(id => document.getElementById(id).className = (id.includes(m==0?'Off':m)?'active':'')); render(); }
    
    function render(targetCtx = ctx, isExport = false) {
        if (!isExport) targetCtx.clearRect(0, 0, canvas.width, canvas.height);
        drawCourt(targetCtx);
        objects.forEach(obj => {
            const isSelected = !isExport && selectedObjs.includes(obj);
            if (obj.type === 'line') drawStyledLine(targetCtx, obj, isSelected);
            else if (obj.type === 'shape') drawShape(targetCtx, obj, isSelected);
            else if (obj.type === 'text') drawTextObj(targetCtx, obj, isSelected);
            else drawPlayerObj(targetCtx, obj, isSelected);
        });
        if (tempShape && !isExport) drawShape(targetCtx, tempShape, false);
        if (selectionBox && !isExport) { targetCtx.strokeStyle = "rgba(0,123,255,0.8)"; targetCtx.setLineDash([5,5]); targetCtx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.w, selectionBox.h); targetCtx.setLineDash([]); }
        if (!isExport) { managePanelUI(); updateTerminalButtons(); }
    }

    function drawTextObj(targetCtx, obj, isSelected) {
        targetCtx.save(); const fs = obj.fontSize || 24; targetCtx.font = fs + "px sans-serif"; targetCtx.textBaseline = "top";
        const w = targetCtx.measureText(obj.text).width, h = fs; obj._lastW = w; obj._lastH = h; 
        if (obj.bgColor) { targetCtx.fillStyle = obj.bgColor; targetCtx.fillRect(obj.x - 4, obj.y - 4, w + 8, h + 8); }
        targetCtx.fillStyle = obj.color || "#000"; targetCtx.fillText(obj.text, obj.x, obj.y);
        if (isSelected) {
            targetCtx.strokeStyle = "#007bff"; targetCtx.setLineDash([4,4]); targetCtx.strokeRect(obj.x - 5, obj.y - 5, w + 10, h + 10);
            targetCtx.setLineDash([]); targetCtx.fillStyle = "white"; targetCtx.strokeStyle = "#007bff";
            [{x: obj.x-5, y: obj.y-5}, {x: obj.x+w+5, y: obj.y-5}, {x: obj.x-5, y: obj.y+h+5}, {x: obj.x+w+5, y: obj.y+h+5}].forEach(p => { targetCtx.beginPath(); targetCtx.arc(p.x, p.y, 5, 0, Math.PI*2); targetCtx.fill(); targetCtx.stroke(); });
        }
        targetCtx.restore();
    }

    function drawPlayerObj(targetCtx, obj, isSelected) {
        targetCtx.save(); targetCtx.font = "bold 24px sans-serif"; targetCtx.textAlign = "center"; targetCtx.textBaseline = "middle";
        const textW = targetCtx.measureText(obj.label).width, radius = Math.max(22, (textW / 2) + 8);
        if (obj.hasBall) { targetCtx.fillStyle = "#fff"; targetCtx.beginPath(); targetCtx.arc(obj.x, obj.y, radius, 0, Math.PI * 2); targetCtx.fill(); targetCtx.strokeStyle = obj.color || "#000"; targetCtx.lineWidth = 2.5; targetCtx.stroke(); }
        targetCtx.fillStyle = obj.color || "#000"; targetCtx.fillText(obj.label, obj.x, obj.y);
        if (isSelected) { targetCtx.strokeStyle = "#007bff"; targetCtx.setLineDash([4,4]); targetCtx.strokeRect(obj.x-radius-3, obj.y-radius-3, (radius+3)*2, (radius+3)*2); }
        targetCtx.restore();
    }

    function drawShape(targetCtx, obj, isSelected) {
        targetCtx.save(); const pts = obj.points, color = obj.color || "#000"; targetCtx.beginPath();
        if (obj.shape === 'rect') { targetCtx.moveTo(pts[0].x, pts[0].y); targetCtx.lineTo(pts[1].x, pts[1].y); targetCtx.lineTo(pts[2].x, pts[2].y); targetCtx.lineTo(pts[3].x, pts[3].y); targetCtx.closePath(); }
        else if (obj.shape === 'circle') { const r = Math.sqrt(Math.pow(pts[1].x - pts[0].x, 2) + Math.pow(pts[1].y - pts[0].y, 2)); targetCtx.arc(pts[0].x, pts[0].y, r, 0, Math.PI * 2); }
        else if (obj.shape === 'tri') { targetCtx.moveTo(pts[0].x, pts[0].y); targetCtx.lineTo(pts[1].x, pts[1].y); targetCtx.lineTo(pts[2].x, pts[2].y); targetCtx.closePath(); }
        if (obj.isFill) { targetCtx.globalAlpha = obj.opacity || 0.5; targetCtx.fillStyle = color; targetCtx.fill(); }
        if (obj.isStroke) { targetCtx.globalAlpha = 1.0; targetCtx.strokeStyle = isSelected ? "#007bff" : color; targetCtx.lineWidth = 2.5; if (obj.style === 'dashed') targetCtx.setLineDash([8, 8]); targetCtx.stroke(); }
        if (isSelected) { targetCtx.setLineDash([]); targetCtx.fillStyle = "white"; targetCtx.strokeStyle = "#007bff"; pts.forEach(p => { targetCtx.beginPath(); targetCtx.arc(p.x, p.y, 6, 0, Math.PI*2); targetCtx.fill(); targetCtx.stroke(); }); }
        targetCtx.restore();
    }

    function drawStyledLine(targetCtx, obj, isSelected) {
        targetCtx.save(); targetCtx.strokeStyle = isSelected ? "#007bff" : (obj.color || "#000"); targetCtx.lineWidth = 2.5; targetCtx.lineCap = "round";
        const pts = obj.points; let pathPts = [];
        if (obj.lineType === 'ortho') { pathPts.push(pts[0]); for (let i = 1; i < pts.length; i++) { let flip = obj.flipOrtho; if (i % 2 === 0) flip = !flip; if (flip) pathPts.push({ x: pts[i-1].x, y: pts[i].y }); else pathPts.push({ x: pts[i].x, y: pts[i-1].y }); pathPts.push(pts[i]); } }
        else if (obj.lineType === 'curve' && pts.length === 3) { for (let i = 0; i <= 40; i++) { const t = i / 40; pathPts.push({ x: (1-t)**2 * pts[0].x + 2*(1-t)*t * pts[1].x + t**2 * pts[2].x, y: (1-t)**2 * pts[0].y + 2*(1-t)*t * pts[1].y + t**2 * pts[2].y }); } }
        else pathPts = pts;
        if (obj.style === 'dashed') targetCtx.setLineDash([8, 8]); 
        targetCtx.beginPath(); targetCtx.moveTo(pathPts[0].x, pathPts[0].y);
        if (obj.style === 'zigzag' && obj.lineType !== 'ortho') { let totalDist = 0; for (let i = 1; i < pathPts.length; i++) { const prev = pathPts[i-1], p = pathPts[i], dx = p.x-prev.x, dy = p.y-prev.y, dist = Math.sqrt(dx*dx+dy*dy), angle = Math.atan2(dy, dx), segments = Math.floor(dist / 2); for(let j=1; j<=segments; j++){ const step = j/segments, currX = prev.x + dx*step, currY = prev.y + dy*step, offset = Math.sin((totalDist + dist*step) * 0.3) * 3.5; targetCtx.lineTo(currX + Math.cos(angle+Math.PI/2)*offset, currY + Math.sin(angle+Math.PI/2)*offset); } totalDist += dist; } }
        else pathPts.forEach(p => targetCtx.lineTo(p.x, p.y));
        targetCtx.stroke();
        if (pathPts.length > 1 && obj.terminal !== 'none') { targetCtx.setLineDash([]); const last = pathPts[pathPts.length-1], prev = pathPts[pathPts.length-2], angle = Math.atan2(last.y - prev.y, last.x - prev.x); targetCtx.fillStyle = targetCtx.strokeStyle; if (obj.terminal === 'arrow') { targetCtx.beginPath(); targetCtx.moveTo(last.x, last.y); targetCtx.lineTo(last.x-14*Math.cos(angle-0.45), last.y-14*Math.sin(angle-0.45)); targetCtx.lineTo(last.x-14*Math.cos(angle+0.45), last.y-14*Math.sin(angle+0.45)); targetCtx.fill(); } else if (obj.terminal === 'block') { const bx = Math.sin(angle)*10, by = Math.cos(angle)*10; targetCtx.beginPath(); targetCtx.moveTo(last.x+bx, last.y-by); targetCtx.lineTo(last.x-bx, last.y+by); targetCtx.lineWidth=4; targetCtx.stroke(); } }
        if (isSelected) { targetCtx.setLineDash([]); targetCtx.fillStyle = "white"; targetCtx.strokeStyle = "#007bff"; pts.forEach(p => { targetCtx.beginPath(); targetCtx.arc(p.x, p.y, 6, 0, Math.PI*2); targetCtx.fill(); targetCtx.stroke(); }); }
        targetCtx.restore();
    }

    function distToSegment(px,py,p1,p2) { const dx = p2.x-p1.x, dy = p2.y-p1.y, l2 = dx*dx+dy*dy; if(l2 === 0) return Math.sqrt((px-p1.x)**2+(py-p1.y)**2); let t = Math.max(0, Math.min(1, ((px-p1.x)*dx+(py-p1.y)*dy)/l2)); return Math.sqrt((px-(p1.x+t*dx))**2+(py-(p1.y+t*dy))**2); }
    function managePanelUI() { const panel = document.getElementById('text-editor-panel'); const sel = selectedObjs.length === 1 && selectedObjs[0].type === 'text' ? selectedObjs[0] : null; if(sel) { panel.style.display = 'flex'; document.getElementById('editorTextColor').value = sel.color; document.getElementById('editorBgEnable').checked = !!sel.bgColor; if(sel.bgColor) document.getElementById('editorBgColor').value = sel.bgColor; document.getElementById('editorFontSize').value = Math.round(sel.fontSize); } else { panel.style.display = 'none'; } }
    function updateTerminalButtons() { if(selectedObjs.length === 1 && selectedObjs[0].type === 'line') { const t = selectedObjs[0].terminal; document.getElementById('termArrowBtn').className = t==='arrow'?'active':''; document.getElementById('termBlockBtn').className = t==='block'?'active':''; document.getElementById('termNoneBtn').className = t==='none'?'active':''; } }
    function updateTextFromPanel() { const sel = selectedObjs.find(o => o.type === 'text'); if(!sel) return; sel.color = document.getElementById('editorTextColor').value; sel.bgColor = document.getElementById('editorBgEnable').checked ? document.getElementById('editorBgColor').value : null; sel.fontSize = parseInt(document.getElementById('editorFontSize').value); render(); }
    function setMode(m) { mode = m; ['moveBtn','drawBtn','shapeBtn','textBtn'].forEach(id => document.getElementById(id).className = (id.startsWith(m)?'active':'')); }
    function setShapeType(s) { currentShapeType = s; setMode('shape'); ['circBtn','rectBtn','triBtn'].forEach(id => document.getElementById(id).className = (id.startsWith(s.substring(0,3))?'active':'')); }
    function toggleFill() { isFill = !isFill; document.getElementById('fillBtn').className = isFill ? 'active' : ''; selectedObjs.forEach(o => { if(o.type==='shape') o.isFill = isFill; }); render(); }
    function toggleStroke() { isStroke = !isStroke; document.getElementById('strokeBtn').className = isStroke ? 'active' : ''; selectedObjs.forEach(o => { if(o.type==='shape') o.isStroke = isStroke; }); render(); }
    function changeOpacity(v) { currentOpacity = parseFloat(v); selectedObjs.forEach(o => { if(o.type==='shape') o.opacity = currentOpacity; }); render(); }
    function changeColor(color) { save(); selectedObjs.forEach(o => o.color = color); render(); }
    function changeLineType(type) { currentLineType = type; ['straight','curve','ortho'].forEach(t => document.getElementById(t+'Btn').className = (type===t?'active':'')); selectedObjs.forEach(o => { if (o.type === 'line') { o.lineType = type; if(type === 'curve' && o.points.length === 2) o.points.splice(1, 0, {x:(o.points[0].x+o.points[1].x)/2, y:(o.points[0].y+o.points[1].y)/2-20}); } }); render(); }
    function changeLineStyle(s) { currentPenStyle = s; ['solid','dashed','zigzag'].forEach(style => document.getElementById(style+'Btn').className = (s===style?'active':'')); selectedObjs.forEach(o => { if (o.type === 'line' || o.type === 'shape') o.style = s; }); render(); }
    function changeTerminal(t) { currentTerminal = t; ['termArrowBtn','termBlockBtn','termNoneBtn'].forEach(id => document.getElementById(id).className = (id.toLowerCase().includes(t)?'active':'')); selectedObjs.forEach(o => { if (o.type === 'line') o.terminal = t; }); render(); }
    
    function applyTemplate(type) {
        if (objects.length > 0 && !confirm("リセットして配置しますか？")) return;
        save(); objects = []; const w = canvas.width, h = canvas.height;
        const base = isPortrait ? [{ label: 'GL', x: w/2, y: h-60 }, { label: 'xGL', x: w/2, y: 60 }] : [{ label: 'GL', x: 60, y: h/2 }, { label: 'xGL', x: w-60, y: h/2 }];
        let p = [];
        if (!isPortrait) {
            const sideDist = 160;
            if (type === 'default') p = [{l:'1',x:sideDist,y:h/2+100},{l:'2',x:sideDist,y:h/2-100},{l:'3',x:300,y:h/2+100},{l:'4',x:300,y:h/2-100},{l:'x1',x:w-sideDist,y:h/2+100},{l:'x2',x:w-sideDist,y:h/2-100},{l:'x3',x:w-300,y:h/2+100},{l:'x4',x:w-300,y:h/2-100}];
            else if (type === '3-1') p = [{l:'1',x:220,y:h/2},{l:'2',x:320,y:h-100},{l:'3',x:320,y:100},{l:'4',x:w-220,y:h/2},{l:'x1',x:320,y:h/2},{l:'x2',x:w-420,y:h-150},{l:'x3',x:w-420,y:150},{l:'x4',x:w-180,y:h/2}];
            else if (type === '4-0') p = [{l:'1',x:200,y:h/2+110},{l:'2',x:200,y:h/2-110},{l:'3',x:350,y:h/2+150},{l:'4',x:350,y:h/2-150},{l:'x1',x:w-400,y:h/2+80},{l:'x2',x:w-400,y:h/2-80},{l:'x3',x:w-250,y:h/2+130},{l:'x4',x:w-250,y:h/2-130}];
        } else {
            const sideDist = 120;
            if (type === 'default') p = [{l:'1',x:w/2+100,y:h-sideDist},{l:'2',x:w/2-100,y:h-sideDist},{l:'3',x:w/2+100,y:h-300},{l:'4',x:w/2-100,y:h-300},{l:'x1',x:w/2+100,y:sideDist},{l:'x2',x:w/2-100,y:sideDist},{l:'x3',x:w/2+100,y:300},{l:'x4',x:w/2-100,y:300}];
            else if (type === '3-1') p = [{l:'1',x:w/2,y:h-220},{l:'2',x:w-100,y:h-320},{l:'3',x:100,y:h-320},{l:'4',x:w/2,y:220},{l:'x1',x:w/2,y:320},{l:'x2',x:w-150,y:420},{l:'x3',x:150,y:420},{l:'x4',x:w/2,y:180}];
            else if (type === '4-0') p = [{l:'1',x:w/2+110,y:h-200},{l:'2',x:w/2-110,y:h-200},{l:'3',x:w/2+150,y:h-350},{l:'4',x:w/2-150,y:h-350},{l:'x1',x:w/2+80,y:400},{l:'x2',x:w/2-80,y:400},{l:'x3',x:w/2+130,y:250},{l:'x4',x:w/2-130,y:250}];
        }
        base.forEach(b => objects.push({ type:'player', x:b.x, y:b.y, label:b.label, hasBall:false, color:'#000000' }));
        p.forEach(x => objects.push({ type:'player', x:x.x, y:x.y, label:x.l, hasBall:false, color:'#000000' }));
        render();
    }

    function addPlayer(team) { save(); const labels = objects.filter(obj => obj.type === 'player').map(obj => obj.label); let n = 1; if (team === 'home') { while (labels.includes(n.toString())) { n++; } } else { while (labels.includes('x' + n)) { n++; } } const label = team === 'home' ? n.toString() : 'x' + n; objects.push({ type:'player', x: canvas.width/2, y: canvas.height/2, label: label, hasBall: false, color: '#000000' }); render(); }
    function addSpecial(label) { save(); objects.push({ type:'player', x: canvas.width/2, y: canvas.height/2, label: label, hasBall: false, color: '#000000' }); render(); }
    function toggleBall() { save(); selectedObjs.forEach(o => { if (o.type === 'player') o.hasBall = !o.hasBall; }); render(); }
    function deleteSelected() { if(selectedObjs.length > 0) { save(); objects = objects.filter(o => !selectedObjs.includes(o)); selectedObjs = []; render(); } }
    function undo() { if (history.length > 0) { objects = JSON.parse(history.pop()); selectedObjs = []; render(); } }
    function clearAll() { if(confirm("リセットしますか？")) { save(); objects = []; selectedObjs = []; render(); } }
    
    function exportImage() {
        const fileName = prompt("保存するファイル名:", "futsal_board");
        if (!fileName) return;
        const offCanvas = document.createElement('canvas');
        offCanvas.width = canvas.width; offCanvas.height = canvas.height;
        const octx = offCanvas.getContext('2d');
        octx.fillStyle = "#ffffff"; octx.fillRect(0, 0, offCanvas.width, offCanvas.height);
        render(octx, true);
        const link = document.createElement('a');
        link.download = fileName + '.png'; link.href = offCanvas.toDataURL('image/png'); link.click();
    }

    function toggleOrientation() {
        save(); const oldW = canvas.width, oldH = canvas.height; isPortrait = !isPortrait; canvas.width = oldH; canvas.height = oldW;
        objects.forEach(obj => {
            const rotateCoords = (x, y) => { return isPortrait ? { nx: y, ny: oldW - x } : { nx: oldH - y, ny: x }; };
            if (obj.type === 'player' || obj.type === 'text') { const res = rotateCoords(obj.x, obj.y); obj.x = res.nx; obj.y = res.ny; }
            else if (obj.points) { obj.points.forEach(p => { const res = rotateCoords(p.x, p.y); p.x = res.nx; p.y = res.ny; }); }
        });
        document.getElementById('toggleOrientationBtn').innerText = isPortrait ? "向き：縦" : "向き：横"; render();
    }

    window.onload = () => { updateSaveList(); render(); };
</script>
</body>
</html>
